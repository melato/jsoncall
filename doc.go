// Copyright 2024 Alex Athanasopoulos.
// SPDX-License-Identifier: Apache-2.0

/*
Package jsoncall facilitates creating HTTP web services from Go interfaces,
using reflection to marshal/unmarshal Go method inputs/outputs to/from a single JSON object.

To call a method, the client:
  - Puts each input parameter in a [string]any map.
  - marshals this map to JSON
  - constructs a request url by appending the name of method to a base URL
  - makes an HTTP POST request with the parameters JSON map as the request body
  - Gets the HTTP response status and response body
  - The response body is a [string]any map, with one entry for each method output.

The names of the input parameters, the outputs and the methods can be customized with an ApiDescriptor.
There is support for api descriptors to be specified in JSON.

If there is no api descriptor, a default descriptor is used that specifies:
  - The method name is the name of the Go method.
  - The input parameters of each method are named "p1", "p2", ...
  - If there is exactly one error output (of type "error"), it is named "error".
  - If there is exactly one non-error output, it is named "result".
  - Any other non-error outputs are named "r1", "r2", ....
    The number is the output name is the position of the output among all outputs, starting from 1.

The client and the server implement and call methods of a user-specified api interface type.
The server operates entirely via reflection, using reflect.Value.Call() to call api methods.
The Go client can use a stub implementation of the api interface, which can be generated by the jsoncall/generate package.
Using this stub implementation, the client calls methods of the same Go interface that the server implements.

- If the HTTP status is success (2xx):

  - It unmarshals the response body into a struct that contains an appropriately
    typed and named field for each non-error output of the method.
  - It sets each error output to nil
  - It returns these outputs

- If the HTTP status is not success (2xx):

  - It unmarshals the response body into a *jsoncall.Error
  - It returns this *Error for the method's error outputs, if any
  - It returns zero values for the method's remaining outputs

The Server:
  - Determines the method name from the url.  If it doesn't find the method, it returns an error.
  - It calls the receiver callback to produce a receiver for the method
  - It unmarshalls the method inputs
  - It calls the method with the receiver and the inputs
  - It marshals the outputs into the response body
  - If there is any error in the above,
    or if the method returns an output that is declared as "error" and is not nil,
    the server returns an error HTTP status,
    it wraps the error message in an Error and marshals this error in the response body.

Customization
  - The keys used by input/output maps can be configured for each method.  They default to "P1", "P2", ...
  - The path that is added to the base url can be configured for each method.  It defaults to the method name.

Both Client and Server have hooks for things like providing/checking authentication via HTTP headers

Jsonrpc 2.0 was considered as a protocol for marshalling/unmarshalling parameters, but it cannot be easily
implemented in Go with encoding/json using a single pass to parse the input data.

Putting the method name in the url allows us to know how to unmarshal the body of the request into the arguments.

Putting the method parameters in a map allows us to unmarshal them into a struct (generated via reflection) that has a field for each parameter.
If we had put the parameters in an array, we could not unmarshal them into different types using encoding/json.
We could only unmarshal them into a generic []any.
*/
package jsoncall
